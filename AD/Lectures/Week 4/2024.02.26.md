# Reading notes

## Greedy algorithms

*Greedy algorithms* always makes the locally optimal choice in the hope that this choice leads to a globally optimal solution.

The steps of a *greedy algorithm*:
- Determine the optimal substructure of the problem
- Develop a recursive solution
- Show that if you make the greedy choice, then only one subproblem remains
- Prove that it is always safe to make the greedy choice
- Develop a recursive algorithm that implements the greedy strategy
- Convert the recursive algorithm to an iterative algorithm

### Activity-selection problems

**Theorem 15.1**
Consider any nonempty subproblem $S_k$, and let $a_m$ be an activity in $S_k$ with the earliest finish time. Then $a_m$ is included in some maximum-size subset of mutually compatible activities of $S_k$.

### RECURSIVE-ACTIVITY-SELECTOR

Let $s$ and $f^2$ be arrays of start and finish time of the activities.

Index $k$ defines the subproblem $S_k$.

The procedure assumes $n$ input activities are already ordered by monotonically increasing finish times.



```
RECURSIVE-ACTIVITY-SELECTOR (s, f, k, n)
m = k + 1
while m ≤ n and s[m] < f [k] // find the first activity in Sk to finish
	m = m + 1
if m ≤ n
	return {a_m} ∪ RECURSIVE-ACTIVITY-SELECTOR (s, f, m, n)
else return ∅
```


# Slides notes
	