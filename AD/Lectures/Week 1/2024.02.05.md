# Reading notes
[CLRS 2.1]

**Algorithms**
Informally, an *algorithm* is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.

**Data structures**
A *data structure* is a way to store and organise data in order to facilitate access and modifications. Using the appropriate data structure or structures is an important part of algorithm design. No single data structure works well for all purposes, and so you should know the strengths and limitations of several of them.

## Algorithms

The numbers to be sorted are known as the *keys*.

*Satellite data* is the data associated with the *keys*.

Together, *satellite data* and *keys* form a *record*.
### Insertion sort
*Insertion sort* is a *sorting algorithm*.

**Input**: A sequence of $n$ numbers $\left\langle a_1, a_2, \ldots, a_n\right\rangle$.

**Output**: A *permutation* (reordering) $\left\langle a_1^{\prime}, a_2^{\prime}, \ldots, a_n^{\prime}\right\rangle$ of the input sequence such that $a_1^{\prime} \leq a_2^{\prime} \leq \cdots \leq a_n^{\prime}$.

![Animation 1](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)
![Animation 2](https://upload.wikimedia.org/wikipedia/commons/2/24/Sorting_insertion_sort_anim.gif)

Pseudocode for instertion sort:
```C
INSERTION-SORT(A, n)
for i = 2 to n
	key = A[i]
	// Insert A[i] into the sorted subarray A[1 : i – 1].
	j = i – 1
	while j > 0 and A[j] > key
		A[j + 1] = A[j]
		j = j – 1
	A[j + 1] = key
```

At the beginning of each iteration of the *for* loop, which is indexed by $i$, the *subarray* consisting of elements $\texttt{A[1:i-1]}$ constitutes the currently sorted array, while $\texttt{A[i+1:n]}$ constitutes the array of *keys* that still need to be sorted.

#### Loop invariant
The *subarray* in this case are the elements originally in positions $\texttt{A[1:i-1]}$ but in sorted order. We state these properties of the *subarray* as a *loop invariant*.
![[Pasted image 20240129154647.png]]

*Loop invariants* help us understand why an algorithm is correct.

When using a *loop invariant* we need to show three things:

**Initialisation**: True prior to the first iteration.

**Maintenance**: If true prior to an iteration then remains true before the next iteration.

**Termination**: The loop terminates and the invariant gives us a useful property to help show that the algorithm is correct.

Let us check that these hold for *insertion sort*:

**Initialisation**: Prior to the first iteration $i=2$ and thus $\texttt{A[1:i-1]}$ contains just one element, $\texttt{A[1]}$. This array is sorted, since an array with just one element is always sorted, which makes our condition true.

**Maintenance**: We must show that each iteration maintains the *loop invariant*. By *incrementing* $i$ for every iteration of the $\texttt{for}$ loop we preserve the *loop invariant* by moving $\texttt{A[i-1]}$, $\texttt{A[i-2]}$, and $\texttt{A[i-3]}$ until we find the proper position for $\texttt{A[i]}$.  

**Termination**: The loop variable $i$ starts at 2 and increases by 1 in each iteration. Once $i$'s value exceeds $n$ in the first line, the loop terminates.

## Pseudocode conventions
- In loops, the keywords *to* and *downto* are used when its loop counter increments and decrements for each iteration.
- || is used for comments.
- Variables are local to a given procedure unless it is explicitly indicated.
- $\texttt{A[i]}$ indicates the $i$th elements of array $A$. Most arrays in **CLRS** use 1-origin indexing.
- ":" denotes a *subarray*, e.g. $A[i:j]$ is the *subarray* of all the elements from the $i$th to the $j$th position in array $A$.
- Compound data is organised into *objects*, compounded of *attributes*. For object $x$ with attribute $f$ we denote the attribute as: $x.f$
- A variable representing an array or object is a reference to the data representing the array or object. 
- NIL refers to no object at all
- We pass parameters to a procedure *by value*: the called procedure receives its own copy of the parameters, and if it assigns a value to a parameter, the change is *not* seen by the calling procedure. a parameter, the change is not seen by the calling procedure. When objects are passed, the pointer to the data representing the object is copied, but the object’s attributes are not. if x is a parameter of a called procedure, the assignment x = y within the called procedure is not visible to the calling procedure. The assignment x.f = 3, however, is visible if the calling procedure has a pointer to the same object as x. Similarly, arrays are passed by pointer, so that a pointer to the array is passed, rather than the entire array, and changes to individual array elements are visible to the calling procedure.
- A *return* statement immediately transfers control back to the point of call in the calling procedure. Most *return* statements also take a value to pass back to the caller.
- Boolean operators "$\texttt{and}$" and "$\texttt{or}$" are *short circuiting*. The expression "$x~\texttt{and}~y$" evaluates the expression by first evaluating $x$.  *Short-circuiting* operators allow us to write boolean expressions such as “$x ≠ NIL ~\texttt{and}~x.f = y$” without worrying about what happens upon evaluating $x.f$ when $x$ is NIL.

# Lecture notes
