# Reading notes
[CLRS 2.1]

**Algorithms**
Informally, an *algorithm* is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.

**Data structures**
A *data structure* is a way to store and organise data in order to facilitate access and modifications. Using the appropriate data structure or structures is an important part of algorithm design. No single data structure works well for all purposes, and so you should know the strengths and limitations of several of them.

## Algorithms

The numbers to be sorted are known as the *keys*.

*Satellite data* is the data associated with the *keys*.

Together, *satellite data* and *keys* form a *record*.
### Insertion sort
*Insertion sort* is a *sorting algorithm*.

**Input**: A sequence of $n$ numbers $\left\langle a_1, a_2, \ldots, a_n\right\rangle$.

**Output**: A *permutation* (reordering) $\left\langle a_1^{\prime}, a_2^{\prime}, \ldots, a_n^{\prime}\right\rangle$ of the input sequence such that $a_1^{\prime} \leq a_2^{\prime} \leq \cdots \leq a_n^{\prime}$.

![Animation 1](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)
![Animation 2](https://upload.wikimedia.org/wikipedia/commons/2/24/Sorting_insertion_sort_anim.gif)

Pseudocode for instertion sort:
```C
INSERTION-SORT(A, n)
for i = 2 to n
	key = A[i]
	// Insert A[i] into the sorted subarray A[1 : i – 1].
	j = i – 1
	while j > 0 and A[j] > key
		A[j + 1] = A[j]
		j = j – 1
	A[j + 1] = key
```

At the beginning of each iteration of the *for* loop, which is indexed by $i$, the *subarray* consisting of elements $\texttt{A[1:i-1]}$ constitutes the currently sorted array, while $\texttt{A[i+1:n]}$ constitutes the array of *keys* that still need to be sorted.

#### Loop invariant
The *subarray* in this case are the elements originally in positions $\texttt{A[1:i-1]}$ but in sorted order. We state these properties of the *subarray* as a *loop invariant*.
![[Pasted image 20240129154647.png]]

*Loop invariants* help us understand why an algorithm is correct.

When using a *loop invariant* we need to show three things:

**Initialisation**: True prior to the first iteration.

**Maintenance**: If true prior to an iteration then remains true before the next iteration.

**Termination**: The loop terminates and the invariant gives us a useful property to help show that the algorithm is correct.

Let us check that these hold for *insertion sort*:

**Initialisation**: Prior to the first iteration $i=2$ and thus $\texttt{A[1:i-1]}$ contains just one element, $\texttt{A[1]}$. This array is sorted, since an array with just one element is always sorted, which makes our condition true.

**Maintenance**: We must show that each iteration maintains the *loop invariant*. By *incrementing* $i$ for every iteration of the $\texttt{for}$ loop we preserve the *loop invariant* by moving $\texttt{A[i-1]}$, $\texttt{A[i-2]}$, and $\texttt{A[i-3]}$ until we find the proper position for $\texttt{A[i]}$.  

**Termination**: The loop variable $i$ starts at 2 and increases by 1 in each iteration. Once $i$'s value exceeds $n$ in the first line, the loop terminates.

## Pseudocode conventions
- In loops, the keywords *to* and *downto* are used when its loop counter increments and decrements for each iteration.
- || is used for comments.
- Variables are local to a given procedure unless it is explicitly indicated.
- $\texttt{A[i]}$ indicates the $i$th elements of array $A$. Most arrays in **CLRS** use 1-origin indexing.
- ":" denotes a *subarray*, e.g. $A[i:j]$ is the *subarray* of all the elements from the $i$th to the $j$th position in array $A$.
- Compound data is organised into *objects*, compounded of *attributes*. For object $x$ with attribute $f$ we denote the attribute as: $x.f$
- A variable representing an array or object is a reference to the data representing the array or object. 
- NIL refers to no object at all
- We pass parameters to a procedure *by value*: the called procedure receives its own copy of the parameters, and if it assigns a value to a parameter, the change is *not* seen by the calling procedure. a parameter, the change is not seen by the calling procedure. When objects are passed, the pointer to the data representing the object is copied, but the object’s attributes are not. if x is a parameter of a called procedure, the assignment x = y within the called procedure is not visible to the calling procedure. The assignment x.f = 3, however, is visible if the calling procedure has a pointer to the same object as x. Similarly, arrays are passed by pointer, so that a pointer to the array is passed, rather than the entire array, and changes to individual array elements are visible to the calling procedure.
- A *return* statement immediately transfers control back to the point of call in the calling procedure. Most *return* statements also take a value to pass back to the caller.
- Boolean operators "$\texttt{and}$" and "$\texttt{or}$" are *short circuiting*. The expression "$x~\texttt{and}~y$" evaluates the expression by first evaluating $x$.  *Short-circuiting* operators allow us to write boolean expressions such as “$x ≠ NIL ~\texttt{and}~x.f = y$” without worrying about what happens upon evaluating $x.f$ when $x$ is NIL.

# Lecture notes

## Introduction

Knowledge from the course:
- Sorting algorithms
- Graph algorithms
- Fibonacci heaps and binary search trees
- Amortised analysis
- Divide and conquer
- Dynamic programming
- Greedy algorithms
- Proofs

**Assignments**
- To qualify for the exam, 4 out of 5 weekly assignments must be passed
- The assignments can be resubmitted, except for the last 2
- Groups of 3

**Exam**
- 8. April
- 4-hour written ITX exam
- No electronics for the exam
- Partly multiple-choice

**Tips**
- Solve problems similar to the exam (assignments)
- Exercises
- Focus on what is presented in the lectures

## Proofs and loop invariants
![](https://imgs.xkcd.com/comics/fairy_tales.png)

### Proofs
A formal proof is a precise argument that *proves* the truth of a *well-defined* statement.

**Types of proofs**
- Direct proofs
- Contrapositive proofs
- Contradictory proofs
- Proof by induction
- Proof by invariant

#### Direct proof
##### Mean value and variance for a data stream
Suppose that we have a table of $x$ values $x_1,x_2,\cdots,x_n$.

We want to find the *mean value*:
$$
\mu=\left(\sum_{i=1}^n x_i\right) / n
$$
and the *variance*:
$$
\operatorname{Var}(x)=\sum_{i=1}^n\left(x_i-\mu\right)^2 / n
$$

Show with a *direct proof* that 
$$
\operatorname{Var}(x)=\left(\sum_{i=1}^n x_i^2\right) / n-\mu^2
$$

Proof:
$$
\begin{aligned}
& \sum_{i=1}^n\left(x_i^2 / n-2 \mu x_i / n+\mu^2 / n\right) \\
& \sum_{i=1}^n x_i^2 / n-2 \mu \sum_{i=1}^n x_i / n+\mu^2 \\
& \sum_{i=1}^n x_i^2 / n-2 \mu^2+\mu^2
\end{aligned}
$$


#### Contrapositive proof

Instead of showing $A\Rightarrow B$ we can show that $\neg B \Rightarrow \neg A$

#### Contradictory proof

Show a statement $S$ by assuming that $\neg S$ holds.

#### Proof by induction

Can be used when a statement $S$ can be *indexed* by nonnegative whole numbers $n\in\mathbb{N}$.

The proof consists of:
-  the base step $S(0)$
- *Induction*: showing that $S(n)\Rightarrow S(n+1)$ for every $n\in \mathbb{N}$

##### Example
Show that for all $n \in \mathbb{N}$ it holds that $S(n): \sum_{i=1}^n i=n(n+1) / 2$

**Base step**: $S(0): \sum_{i=1}^0 i=0(0+1) / 2$ 

**Induction step**: Suppose $S(n)$.
$$
\sum_{i=1}^{n+1} i=(n+1)+\sum_{i=1}^n i=(n+1)+n(n+1) / 2=(n+1)(n+2) / 2
$$

$S(n+1)$ holds.

#### Proof by invariant

By showing that the *invariant* and *termination condition* holds we can prove the correctness of an algorithm.

##### Bubble sort
[animation](https://algostructure.com/sorting/bubblesort.php)

```C
for i = 1 to n do
	for j = 1 to n − i do
		if A[j] > A[j + 1] then
			swap A[j] and A[j + 1]
```

**Invariant**
- Array $A$ contains $a_1, a_2, \ldots, a_n$
- After each iteration of the outer loop $A[n+1-i], \ldots, A[n]$ contains the $i$ largest elements in sorted order.
- After each iteration of the inner loop it holds that $A[j+1] \geq \max (A[1], \ldots, A[j])$


**Termination condition**
- $i=n$ (outer loop)
- $j=n-i$ (inner loop)

##### Binary search
![[Pasted image 20240205163452.png]]

**Invariant**
Our loop invariant is defined as:
$$
A[low]\leq key \leq A[high] 
$$
where $A[1]\leq key \leq A[size]$


**Termination**

A[i]<key for i< low

A[i] > key for i > high

##### ICan'tBelieveItCanSort
```C
for i = 1 to n do
	for j = 1 to n do
		if A[i] < A[j] then
			swap A[i] and A[j]
```

**Invariant**:
- **Outer loop**: $A[1],...,A[i]$ is sorted and $A[i]=\max\{\alpha_1,...,\alpha_n\}$ 
- **Inner loop**: $A[1],...,A[\min(i,j)]$ is sorted and $A[i]\geq\max(A[1],...,A[j])$

**Termination**: $i=n$

# Exercises
[AD handouts 4/5, April 23 2018]

## 1
*Q*: Prove that $x^2-y^2=1$ has no solutions for positive whole numbers $x,y$.

*A*: We'll try to prove that the statement holds. Use the fact that $x^2-y^2=(x+y)(x-y)$

$$
(x+y)(x-y)=1
$$
We can see now that $y$ is both negative and positive. This contradicts the condition that $y$ is positive.
## 2

*Q*: Prove that $x^2-y^2=10$ has no solutions for positive whole numbers $x,y$.

*A*: We'll try to prove that the statement holds. Use the fact that $x^2-y^2=(x+y)(x-y)$

$$
(x+y)(x-y)=10
$$
We can see now that $y$ is both negative and positive. This contradicts the condition that $y$ is positive.

## 3

*Q*: Show that if $a$ is rational and $b$ is irrational then $a+b$ is an irrational number.

*A*: We can write the equation using fractions and try to show the *contradictory* statement
$$
\frac{x}{y}+b=\frac{z}{w}
$$
We can move the $a$ to the other side
$$
b=\frac{z}{w}-\frac{x}{y}
$$
Subtract the fraction
$$
b=\frac{z-x}{w-y}
$$
We have now shown that $b$ can be represented as a fraction which is a *contradiction* since it is an irrational number.

## 4
*Q*: Give a formula for the sum of the first $n$ odd numbers. (Actually prove via induction?)
$$
f(n)=\sum_{i=1}^n(2 i-1)
$$
*A*: Show via *induction*

**Basis step**
$f(1)=(2\cdot1-1)=1$
Is equal to
$f(1)=1^2=1$

**Induction step**
$f(n+1)=f(n)+2(n+1)-1$
$f(n+1)=f(n)+2n+2-1$
$f(n+1)=f(n)+2n+1$

Is equal to
$f(n+1)=(n+1)^2$
$f(n+1)=n^2+2n+1$

## 5
*Q*: Show that $n!>2^n$ for $n\leq 4$.

*A*:

**Basis step**:
$f_1(4)=4! =24$
$f_2(4)=2^4=16$

**Induction step**:
$f_1(n+1)=(n+1)! = n! \cdot (n+1)$
$f_2(n+1)=2^{n+1}$

$2^{n+1}>n!\cdot (n+1)$
