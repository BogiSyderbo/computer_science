# Reading notes

## Lower bounds for sorting
A *comparison sort* uses only comparisons between elements to gain order information about an input sequence $\left\langle a_1, a_2, \ldots, a_n\right\rangle$

Given two elements $a_i$ and $a_j$, it performs one of these tests to determine their order
- $a_i<a_j, a_i \leq a_j$
- $a_i=a_i, a_i \geq a_j$
- $a_i>a_j$ 

Any *comparison sort* algorithm requires $\Omega(n \lg n)$ comparisons in the worst case.

**Decision tree**:
![[Pasted image 20240213232943.png]]
## Amortised analysis
In an *amortised analysis* you average the time require to perform a sequence of data-structure operations over all the operations performed.

With *amortised analysis* you can show that the average cost of an operation is small even though a single operation in a sequence might be expensive.

*Amortised analysis* guarantees the *average performance* of each operation in the *worst case*.


### Aggregate analysis
Show that for all $n$ a sequence of $n$ operations takes $T(n)$ *worst-case* time in total.

The *amortised cost* per operation is therefore $T(n)/n$

### Potential method
Starting with an initial data structure $D_0$, a sequence of $n$ operations occurs. 

For each $i=1,2, \ldots, n$, let $c_i$ be the actual cost of the $i$ th operation and $D_i$ be the data structure that results after applying the $i$ th operation to data structure $D_{i-1}$. 

A *potential function* $\Phi$ maps each data structure $D_i$ to a real number $\Phi\left(D_i\right)$, which is the potential associated with $D_i$. The *amortised cost* $\hat{C}_i$ of the $i$ th operation with respect to *potential function* $\Phi$ is defined by
$$
\widehat{c}_i=c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right) \text {. }
$$

The *amortised cost* of each operation is therefore its actual cost plus the change in potential due to the operation. The total *amortised cost* of the $n$ operations is
$$
\begin{aligned}
\sum_{i=1}^n \widehat{c}_i & =\sum_{i=1}^n\left(c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)\right) \\
& =\sum_{i=1}^n c_i+\Phi\left(D_n\right)-\Phi\left(D_0\right)
\end{aligned}
$$


# Slides notes
## Potential method
We want to express the *runtime* for a sequence of $n$ operations.

Operation $i$ has a cost of $c_i$and an amortised cost of $\hat{c}_i$,  where the *potential function* has the properties $\Phi(0)=0$ and $\Phi(i)\geq0~\forall i$

# Exercises

## 16.1-1
**Q:** If the set of stack operations includes a **MULTIPUSH** operation, which pushes k items onto the stack, does the $O(1)$ bound on the *amortised cost* of stack operations continue to hold?

**A**: An object cannot be popped from the stack unless it was first pushed. Therefore, the number of times that **POP** can be called on a nonempty stack, including calls within **MULTIPOP**, is at most the number of **PUSH** operations, which is at most $n$. For any value of $n$, any sequence of n **PUSH**, **POP**, and **MULTIPOP** operations takes a total of $O(n)$ time. Averaging over the n operations gives an average cost per operation of $O(n)/n = O(1)$. 

If **MULTIPUSH** and **MULTIPOP** are called with a constant $k$ then this would still hold since you would have the same amount of popping and pushing. The average runtime of each would actually be $\Theta(k)$ since there is a variable runtime cost for **MULTIPUSH**

## 16.1-3

**Q:** Use *aggregate analysis* to determine the *amortised cost* per operation for a sequence of $n$ operations on a data structure in which the $i$th operation costs $i$ if $i$ is an exact power of 2, and 1 otherwise.

**A:** 
$$

    \hat{c}(i)=
\begin{cases}
    i,& \text{if } i=2^i\\
    1,              & \text{otherwise}
\end{cases}
$$

$$
\begin{aligned}
\sum_{i=1}^n \hat{c}_i & =\sum_{i=1}^n\left(c_i+\Phi\left(D_i\right)-\Phi\left(D_{i-1}\right)\right) \\
& =\sum_{i=1}^n c_i+\Phi\left(D_n\right)-\Phi\left(D_0\right) \\
& = \sum_{i=1}^n c_i + \Phi(i) - \Phi(i-1)
\end{aligned}
$$


$$
\begin{aligned}
\sum_{i=1}^n c(i)
& = \sum_{i=1}^{\lceil\lg (n)\rceil} 2^i+\sum_{i \leq n \text { not a power of } 2} 1 \leq \sum_{i=1}^{\lceil\lg (n)\rceil} 2^i+n \\
 & =2^{1+\lceil\lg (n)\rceil}-1+n \leq 4 n-1+n \leq 5 n \in O(n)
\end{aligned}
$$

So, since to find the average, we divide by $n$, the average runtime of each command is $O(1)$.

## 16.2-2
## 16.3-3
## 16.3-4
## 16-4.4
## 16.3-2
