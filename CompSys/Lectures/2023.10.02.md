# Reading notes
Sometimes the main memory is used as a "cache" for the secondary storage (in the form of magnetic disks). This allows for efficient and safe sharing of memory among several programs.
![[Pasted image 20231002131136.png]]
In virtual memory, blocks of memory are called *pages* and are mapped from one set of addresses, called *virtual addresses*, to another set (called *physical addresses*).


# Lecture notes

Recall *memory hierarchy*:
- Registers are at the top
- L1 cache
- L2 cache
- L3 cache
- Random Access Memory (main memory)
- SSD
- Network

The further we go down, the larger, cheaper, and slower.
## Virtual memory

### Physical addressing

Our main memory can be modelled as a large array.

By using physical addressing we can access a specific value in memory directly.

This is *not* usually how modern systems work.

### Virtual addressing

The *MMU* is the *memory management unit*. It uses *virtual addresses* and translates it to chunks of physical addresses is memory.

#### Address spaces
- Linear address spaces
- Virtual address spaces
- Physical address spaces

We'll focus on *linear address spaces*

#### Why use VM?
- It's efficient
- Simplifies memory management
- Isolating address spaces for safety

#### VM as a caching tool
*Virtual memory* is also conceptually an array of contiguous bytes stored on disk.

Usually, physically memory is larger than virtual memory. It is, however, possible to assign more virtual memory than there is physical memory.

*Virtual pages* can be either *unallocated*, *cached*, or *uncached*.

If we $\texttt{malloc}$ too much memory in C, we will get an *out of memory* error because we run out of virtual memory.

##### DRAM Cache Organisation
We want to avoid using slower forms of storage. 

DRAM is about $10\times$ slower than SRAM.

It's fully associative, which is not preferable compared to set associative.

#### Page tables
*Page tables* are arrays of page table entries (PTEs) that maps virtual pages to physical pages.

Each *process* has its own page table.

*Page hit*

*Page miss*

*Page fault*

*Demand paging*

#### Locality
Virtual memory works because of *locality*.

Programs tend to access a set of active virtual pages called the *working set* at any point in time.

#### VM as a memory management tool

Each process has its own virtual address space.

Each virtual page can be mapped to any physical space.

A virtual page can be stored in different physical pages at different times.

##### Linking and loading
Kind of irrelevant?

#### VM as a tool for memory protection
PTEs have *permission bits*.

MMU checks these bits on each access.

### VM Address Translation
#### Page hit
![[Pasted image 20231002141705.png]] 

- Processor sends virtual address to MMU 
- MMU fetches PTE from page table in memory
- MMU sends physical address to cache/memory
- Cache/memory sends data word to processor

#### Page fault
![[Pasted image 20231002141808.png]]
- Processor sends virtual address to MMU 
- MMU fetches PTE from page table in memory
- Valid bit is zero, so MMU triggers page fault exception
- Handler identifies victim (and, if dirty, pages it out to disk)
- Handler pages in new page and updates PTE in memory
- Handler returns to original process, restarting faulting instruction

### Integrating VM and Cache
![[Pasted image 20231002141858.png]]
#### Translation look aside buffer (TLB)
- Small set-associative hardware cache in MMU
- Maps virtaual page numbers to  physical page numbers
- Contains complete page table entries for small number of pages
![[Pasted image 20231002142222.png]]
##### TLB hit
![[Pasted image 20231002142416.png]]
##### TLB miss
![[Pasted image 20231002142436.png]]
TLB misses are *very rare*.

### Multi-level page tables
#### Two-level page table
![[Pasted image 20231002142814.png]]

#### K-level page table
![[Pasted image 20231002143157.png]]

### Acronyms
- PP: Physical page
- VP: Virtual page
- PA: Physical address
- VA: Virtual address
- MMU: Memory address unit
- PT: page table
- PTE: PT entry
- PTEA: PTE address
- TLB: Translation lookside? buffer
- TLBI: TLB Index
- TLBT: TLB Tag
- VPO: VP Offset
- VPN: VP Number
- PPO: PP Offset
- PPN: PP Number
- PTBR: Page Take Base Number

## Summary
Each process has its own virtual memory and its own private linear address space.

Virtual memory is efficient use of locality by caching virtual memory pages.

Virtual memory simplifies memory management.

### Misc.
- Five-level page tables (2017 - https://lwn.net/Articles/717293/)
- Four-level page tables (2004 - https://lwn.net/Articles/106177/)


# Exercises notes



## 5.16
![[Pasted image 20231002150650.png]]
TLB
![[Pasted image 20231002150621.png]]
Page table
![[Pasted image 20231002150629.png]]
### 1 
We have a 32-bit virtual address.

This bit is split into *virtual page offset* (*VPO*), which is equal to *PPO* and *virtual page number* (*VPN*).

We need to *tag* and *set* to check for miss or hit, which is in

Each page is 4KiB large, which is $4\times1024=4096$ bytes.

We need $\lg(4096)=12$ bits, 0-11, for our 

We're fully associative so we don't need a number to check our set, so vpn=tag.

![[Pasted image 20231002154405.png]]
