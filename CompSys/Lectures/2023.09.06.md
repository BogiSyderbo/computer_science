# Reading notes
[COD] 2.1-2.4,2.6-2.7
[JG] 4
## RISC-V
Each each RISC-V arithmetic instruction performs only one operation and must always have exactly three variables. 

This is notation for adding two numbers together:
```
add a, b, c
```
The following sequence of instructions adds  four variables $\texttt{a,b,c,d,e}$
```
add a, b, c    // The sum of b and c is placed in a
add a, a, d    // The sum of b, c, and d is now in a
add a, a, e    // The sum of b, c, d, and e is now in a
```
### Operands
![[Pasted image 20230905144455.png]]
#### Registers
*Registers* are *primitives* used in hardware design that are also visible to the programmer when the computer is completed.

The size of a *register* in the RISC-V architecture is 32 bits and are called *words*. 64 bit registers are called *doublewords*.

The standard naming of registers is x followed by the number (0-31).

RISC-V must include instructions that transfer data between memory and registers. Such instructions are called *data transfer instructions*, usually called *loads*.

The name for this in instruction in RISC-V is $\texttt{lw}$

To access a word in memory, the instruction must supply the *memory address*. 

Memory is just a large, single-dimensional array, with the address acting as the index to that array, starting at 0.

![[Pasted image 20230905145612.png]]



### Language
![[Pasted image 20230905144302.png]]
![[Pasted image 20230905144653.png]]
### Logical operations
![[Pasted image 20230905153522.png]]
#### Shifts
*Shifts* move all the bits in a word to the left or right, filling the emptied bits with 0s. For example, if register $\texttt{x19}$ contained:
```
00000000 00000000 00000000 00001001 = 9
```
The instruction to *shift left* by 4:
```
00000000 00000000 00000000 10010000 = 144
```

Shifting left by $i$ bits gives the identical result as multiplying by $2^i$, just as shifting a decimal number by $i$ digits is equivalent to multiplying by $10^i$. 

*Shift left logical immediate* in RISC-V is $\texttt{slli}$
*Shift right logical immediate* in RISC-V is $\texttt{srli}$

This instruction shifts the value in $\texttt{x19}$ into $\texttt{x11}$:
```
slli x11, x19, 4 // reg x11 = reg x19 << 4 bits
```

### Decision instructions

#### Conditional branches
This instruction means go to statement labelled $\texttt{L1}$ if the value in register $\texttt{rs1}$ equals the value in register $\texttt{rs2}$.
```
beq rs1, rs2, L1
```
$\texttt{beq}$ stands for *branch if equal*

This instruction means go to the statement labelled $\texttt{L1}$ if the value in register $\texttt{rs1}$ does *not* equal the value in register $\texttt{rs2}$.
```
bne rs1, rs2, L1
```
$\texttt{bne}$ stands for *branch if not equal*.

##### Example (*if-then-else conditional*)
Here is an *if-else* statement in C:
```
if (i == j) {f = g + h}
else {f = g − h}
```
![[Pasted image 20230906090553.png]]

Here is the corresponding conditional in RISC-V:

We can assume that *f* through *j* correspond to the five registers $\texttt{}$$\texttt{x19}$ through $\texttt{x23}$
```
bne x22, x23, Else   // go to Else if i ≠ j
add x19, x20, x21    // f = g + h (skipped if i ≠ j)
beq x0, x0, Exit    // if 0 == 0, go to Exit
Else:sub x19, x20, x21  // f = g − h (skipped if i = j)
Exit:
```
#### Loops
##### Example
Here is a *while-loop* in C:
```
while (save[i] == k)
    i += 1;
```

Here is the loop in RISC-V:

Assume that *i* and *k* correspond to the registers $\texttt{x22}$ and $\texttt{x24}$.

Assume also that the base of the array *save* is in $\texttt{x25}$.

```
Loop: slli x10, x22, 2   // Temp reg x10 = i * 4
add x10, x10, x25    // x10 = address of save[i]
lw x9, 0(x10)    // Temp reg x9 = save[i]
bne x9, x24, Exit   // go to Exit if save[i] ≠ k
addi x22, x22, 1    // i = i + 1
beq x0, x0, Loop    // go to Loop
Exit:
```

### Running with RARS
First, [install rars](https://github.com/diku-compSys/compSys-e2023-pub/blob/main/tools/rars.md). Then, run this command where $\texttt{prog.s}$ is a RISC-V file.
```
$ java -jar path/to/rars1_5.jar prog.s
```

# Lecture
C code is compiled into something that can be run

*make* is not C, it is only used for automating commands

**Machine code**: A machine-readable sequence of instructions that cause the computer to change its state.
- A *primitive programming language* directly implemented by hardware
- We use a textual surface syntax called *assembly code*
- An *assembler* turns human-readable assembly code into actual machine code

**RISC-V** is a general-purpose architecture that is open, very new, mostly used for embedded purposes

Concepts in **RISC-V/32** generalise to all other general-purpose architechtures

The two main concepts are *registers* and *instructions*

```
add x1, x2, x3
```

Add the values in register x2 and x3 and put the result in x1

RISC-V/32 exposes a fixed number of registers with a fixed size (32 bits)

RISC-V machine has 32 32-bit integers variables:
```
int32_t x0, x1, x2, x3, x4, x5, x6, x7 x8, x9, x10, x11,
x12, x13, x14, x15 x16, x17, x18, x19, x20, x21, x22, x23
x23, x24, x25, x26, x27, x28, x29, x30, x31;
```


Variables are stored in registers
![[Pasted image 20230906104041.png]]
Sometimes we need more registers than variables for an operation when using high-level languages:
![[Pasted image 20230906104159.png]]


RISC-V registers have conventional names and designated uses
![[Pasted image 20230906104441.png]]


RISC-V does not allow for *pseudoinstructions*, which are essentially shortcuts
![[Pasted image 20230906104750.png]]


https://godbolt.org/


Registers are for *scratch space*; data is primarily stored in *memory*

Programs refer to data by address

Conceptually, we can envision this as a large array of bytes. An *address* is like an index into that array
![[Pasted image 20230906110708.png]]
A *pointer* stores an address

**Addresses** are ultimately just *unsigned integers*

### The Von Neumann Bottleneck
![[Pasted image 20230906111032.png]]
**Reading**: CPU sends address to memory
Memory responds with contents at address

**Writing**: CPU sends address and data to memory
Memory overwrites location with new contents

The *bus* is slow!

The distance between computation and storage is the main performance
obstacle in most programs.

The speed of light is our limitation. Shifting is not instant.

### Words
RISC-V/32 has $2^{32}$ addresses, such that 4GiB can be addressed

### Adress

In C $\texttt{\&x}$ gives us the address of $\texttt{x}$ 

### Byte ordering
These contain the same information

![[Pasted image 20230906112251.png]]
Little endian is mostly used for RISC-V/32. Big endian is standard for networking



### Instructions

An M-byte memory is conceptually an array

In RISC-V/32, *instructions* are also just data stored in memory (4 bytes per instruction)

Memory is *dynamically* addressable, while the registers we operate on are *statically* encoded in instructions.
![[Pasted image 20230906112753.png]]
### Control flow
The *program counter*  or *PC* is a special register that contains the address of the current instruction in memory.

Machine code does not support structured control flow (if, while, for, etc). Thus, we must manipulate the *program counter*.

![[Pasted image 20230906113207.png]]
![[Pasted image 20230906113213.png]]
L0 and L1 are *branches*

#### Loops
Suppose we want to implement c = a × b. Assume:
- c is in register a0.
-  a is in register a1.
-  b is in register a2.

We want to add $a$  to $c$, $b$ times
```
addi a0, a1, 0 # initialise a0 = a1
LOOP: # loop label
beq a2, zero, END # jump to end if no iterations left
addi a2, a2, -1 # decrement b
add a0, a0, a1 # add a to c
jal zero, LOOP # try again
END: # loop end
```


#### Fibonacci
![[Pasted image 20230906114334.png]]

The *address* of an array is the *register* for the *first index* of the array

Each *index* in an array is its *address* plus the index value times 4, equal to shifting left ($\texttt{slli}$). 

For example, the index 
# Master Class
[Link](https://github.com/diku-compSys/compSys-e2023-pub/tree/main/tools/masterclass)
## Unix
### Bash commands
```
history
```

```
clear
```

```
mkdir
```

```
cp
```

```
mv
```

```
rm -rf
```

```
man
```

```
fopen
```

```
fwrite
```

```
fclose
```

### I/O

```
cat
```

```
printf "hello world" > hello.txt
```

```
printf "hello world" >> hello.txt
```

```
wc -l hello.txt
```

counting the amount of files in directory:
```
ls -l | wc -l
```

get the return value of the last command
```
echo $?
```

```
cat hello.txt | grep world
```

```
man 3 printf | grep return
```

```
man 3 printf | grep -A 10 -B 10 return
```

Give permission to execute:
```
chmod +x file.sh
```

## Make
Make is just to avoid having to type in the command to compile every time with the preferred flags.

*Valgrind* checks memory leaks, since C doesn't have *garbage collection*.



## Git
```
git status
```

```
git log
```

```
git add .
```

```
git commit -m "message"
```

```
git push
```

```
cd .gitignore
```

\*.c for ignoring all .c files

```
git revert -m "message" [git reference]
```

```
git stash
```

