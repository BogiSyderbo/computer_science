# Lecture notes

*Concurrent servers* use multiple concurrent flows to serve multiple clients at the same time. 

## Process-based concurrent servers
Spawns separate process for each client.

Connections are independent. 
![[Pasted image 20231030132544.png]]
Makes child blocks for the server to handle each client.

```C
int main(int argc, char **argv)
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    listenfd = compsys_helper_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = accept(listenfd, (SA *) &clientaddr, &clientlen);
        if (fork() == 0) {
            close(listenfd); /* Child closes its listening socket */
            echo(connfd);    /* Child services client */
            close(connfd);   /* Child closes connection with client */
            exit(0);         /* Child exits */
        }
        close(connfd); /* Parent closes connected socket (important!) */
    }
}
```

### Issues

- We must ensure that we avoid 'port leaks', if we forget to close connections from children to clients.

## Event-based concurrent servers

Used for high-performance Web servers and search engines (Node.js, nginx, Tornado)

More difficult to code than process/thread-based designs.
## Thread-based concurrent servers

Similar to process-based servers, but using threads instead of processes.

```C
int main(int argc, char **argv)
{
    int listenfd, *connfdp;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;
    listenfd = compsys_helper_open_listenfd(argv[1]);
    while (1) {
clientlen=sizeof(struct sockaddr_storage);
connfdp = malloc(sizeof(int)); 
*connfdp = accept(listenfd, 
                 (SA *) &clientaddr, &clientlen); 
pthread_create(&tid, NULL, thread, connfdp);
}
```
```C
/* Thread routine */
void *thread(void *vargp)
{
    int connfd = *((int *)vargp);
    pthread_detach(pthread_self()); 
    free(vargp);                    
    echo(connfd);
    close(connfd);
    return NULL;
}
```

Run thread in *detached* mode.

![[Pasted image 20231030134739.png]]
![[Pasted image 20231030135030.png]]


## Security
### Properties
- *Confidentiality*: Concealment of information or resources
- *Authenticity*: Identification and assurance of origin of  info
- *Integrity*: Trustworthiness of data or resources in terms  of preventing improper and unauthorized changes
- *Availability*: Ability to use desired info or resource
- *Non-repudiation*: Offer of evidence that a party indeed  is sender or a receiver of certain information
- *Access control*: Facilities to determine and enforce who  is allowed access to what resources (host, software, network, …)

### Hash functions
Function for deterministically computing a fixed-length output from some variable length input.

Fast to compute, but time consuming to reverse engineer.

#### Hash table
![[Pasted image 20231030142717.png]]
Can't know whether 01 is Angela or Dominic.
### Cryptographic hash functions
A subset of hash functions.

Much slowed and much more difficult to reverse engineer.
### C hashing
```C
typedef uint8_t hashdata_t[32];

void get_data_sha(const char* sourcedata, hashdata_t hash, 
uint32_t data_size, int hash_size) {
  SHA256_CTX shactx;
  unsigned char shabuffer[hash_size];
  sha256_init(&shactx);
  sha256_update(&shactx, sourcedata, data_size);
  sha256_final(&shactx, shabuffer);
  for (int i=0; i<hash_size; i++) {
    hash[i] = shabuffer[i];
}
```

### Uses
#### Checksums
**Packet**
![[Pasted image 20231030143113.png]]
![[Pasted image 20231030143155.png]]

#### Obfuscation
John Dillinger mode![[Pasted image 20231030144037.png]]
![[Pasted image 20231030144029.png]]

Hashes help obfuscate passwords.

## Hash salting
![[Pasted image 20231030144751.png]]

**Non-salted**
```Python
import hashlib
def get_sha256(data):
    return hashlib.sha256(data).digest()
hashed = get_sha256(“some data”)
```
**Salted**
```Python
import hashlib
import string
import random

def get_random_salt():
    return ‘’.join(random.choices(string.ascii_lowercase, k=64))
def get_sha256(data, salt):
to_salt = data + salt
    return hashlib.sha256(to_salt).digest()

salt = get_random_salt() 
hashed_and_salted = get_sha256(“some data”, salt)
```

![[Pasted image 20231030144921.png]]

