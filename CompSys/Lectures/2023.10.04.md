# Lecture notes
## Addressing

### Virtual address
![[Pasted image 20231004102306.png]]
The tag is contained in the VPN.

### Physical address


## Linux virtual memory system
Linux organises a virtual memory space as a set of *areas*
```C
struct vm_area_struct {
	unsigned long vm_start;
	unsigned long vm_end;
	pgprot_t
	vm_page_prot;
	...
};
```

Each *area* describes the properties of a span of virtual memory.
- May cover any number of pages
- *Area* has uniform protection/access bits (read, write, exe).

CPU has no idea what areas are, it's purely a software data structure.
![[Pasted image 20231004104133.png]]
A *segmentation faulr* is when we try no access a page (or anything) that doesn't exist or you don't have permission to access (in some cases).

A *normal page fault* is an exception when we try to access a memory page not currently in RAM.


### Memory mapping
*Memory mapping* is the association of VM areas with disk objects. 
```C
struct vm_area_struct {
	...
	unsigned long
	vm_pgoff;
	struct file
	*vm_file;
	...
};
```




*mmap*
```C
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

Functionally similar to $\texttt{malloc()}$ 
![[Pasted image 20231004105045.png]]


*munmap*
```C
int munmap(void *addr, size_t length);
```

Functionally similar to $\texttt{free()}$


$\texttt{mmap()}$ is powerful but infexible. Smallest granularity of allocation is a page and is a system call and thus fairly slow. Use $\texttt{malloc()}$ instead in most cases.

$\texttt{malloc()}$ will acquire memory at runtime, this region of virtual memory allocated is known as *the heap* (not related to the heap data structure).

It may have multiple heaps, and heaps might not be contiguous.

*The heap* is whatever $\texttt{malloc()}$ manages by default.
![[Pasted image 20231004110713.png]]

### Dynamic memory allocator
Allocator maintains heap as collection of blocks of varying size, each of
which is either *allocated* or *free*.

Types of allocators:
- *Explicit allocator*: application manually allocates and frees space
	- $\texttt{malloc()}$ in C
- *Implicit allocator*: application allocates but freeing is automatic/
	- garbage collection in Java, F#, Haskell

*Implicit allocation* has more overhead.


#### API

```C
void *malloc(size_t size);
```
Returns a pointer to a memory block of at least size bytes.
- May round up to ensure address is always aligned.
- NULL on failure.

```C
void free(void *ptr);
```
- Returns block of memory to heap.
- p must have been returned by $\texttt{malloc()}$ (or one of the variants).

![[Pasted image 20231004111719.png]]


#### Fragmentation
*Internal fragmentation* occurs when the payload is smaller than the block size.
![[Pasted image 20231004112920.png]]
- Overhead of maintaining heap data structures.
- Padding for alignment purposes.
- Explicit policy decisions, e.g. returning a bigger block than necessary because it's faster.

*External fragmentation* occurs when there is enough aggregate heap memory, but no single free block is large enough

![[Pasted image 20231004113113.png]]


# Exercises
## Heap Management
*Implicit free list*
*Immediate coalescing*

Consider an allocator that uses an implicit free list. The payload is preceded by header and a footer, each taking up a single 32-bit word, and containing the size (in bytes) of the block. The header and footer words for a block are always identical.

The size of each memory block must be a multiple of 8 bytes. This means that the least significant three bits of the size is unused for the size, and therefore these are used to encode more information:

- Bit 0 (the least significant bit) indicates the use of the current block: 1 for allocated, 0 for free.
    
- Bit 1 indicates the use of the _previous_ adjacent block: 1 for allocated, 0 for free.
    
- Bit 2 is unused and is always set to 0.
    
- The remaining bits contain the size of the block. We pretend that the least significant 3 bits are zero when interpreting the header/footer as a size.
    

Given the following initial heap contents, show the new contents of the heap after a call to `free(0x100f010)`. Your answers should be given as hex values. Note that the addresses grow from bottom up. Assume that the allocator uses immediate coalescing, that is, adjacent free blocks are merged immediately each time a block is freed.


Since headers and footers are only a single 32-bit word, then the headers and footers have to be word values where the values are identical and do not exceed 