# Reading notes
[JG] 8-9, 11

Functionality of C is seperated into the proper C language and the C library.

The C library includes basic tools such as $\texttt{printf, puts, strtod}$. 

APIs (*application programming interfaces*) allow us to separate the compiler implementation from the library implementation.

The most common compilers for C are $\texttt{gcc}$ and $\texttt{clang}$. 

## C library headers
*Headers* bundles interface descriptions for a number of features, mostly functions.

Most interfaces in the C library are specified as *functions*.
![[Pasted image 20230918124211.png]]

## Mathematical functions
![[Pasted image 20230918124425.png]]
![[Pasted image 20230918124456.png]]
## Opening files
```C
int main(int argc , char* argv[argc +1]) {
	FILE* logfile = fopen("mylog.txt", "a");
	if (! logfile) {
		perror("fopen␣failed");
		return EXIT_FAILURE;
}
fputs("feeling␣fine␣today\n", logfile);
return EXIT_SUCCESS;
}
```
This program opens a file called "$\texttt{mylog.txt}$" in the file system and provides access to it through the variable $\texttt{logfile}$. The mode argument "$\texttt{a}$" opens the file for appending. 

![[Pasted image 20230918124712.png]]

## Format specifiers
![[Pasted image 20230918124645.png]]

## Character classifiers
![[Pasted image 20230918125252.png]]
![[Pasted image 20230918125242.png]]

## Time
![[Pasted image 20230918125355.png]]


## Style
![[Pasted image 20230918125540.png]]

## Pointers
Pointers are one of the most important features of C


# Lecture notes
## Floating point representation
*Normalised* representation has less precision in the fraction

*Normalised* representation has a significand between 0.1 and 1
##  C pointers
*Pointers* are memory addresses.

```C
int x = 2;
printf("x: %d\n", &x);
```
$\texttt{\&x}$ refers to the *pointer* to $\texttt{x}$. This snippet will print the *memory address* of $\texttt{x}$.

```C
int* px;
px = &x;
```

This assigns the *pointer* of $\texttt{x}$ to a variable $\texttt{px}$.

```C
*px = 5;
```

This assigns the *pointer* that $\texttt{x}$ and $\texttt{px}$ point to the value 5.

```C
char** ppx = px
```
This would be a pointer to a pointer (""*pointer pointer*"")
### Arrays
Arrays are just *chunks of memory*.

```C
int main(void) {
  int a[10] = { 1,2,3,4,5,6,7,8,9,10 };

int *p = &a[0];
printf("p: %p\n", (void*)p);
printf("*p: %d\n", *p);

for (int i = 0; i < 10; i++) {
	printf("p: %p\n", (void*)p);
	printf("*p: %d\n", *p);
	p = p + 1; // implicit * sizeof(int)
	}
}
```

This will print out the addresses of an array. The address pointers are 4 bytes apart in memory:
```
p: 0x7fff65c27800
*p: 1
p: 0x7fff65c27800
*p: 1
p: 0x7fff65c27804
*p: 2
p: 0x7fff65c27808
*p: 3
p: 0x7fff65c2780c
*p: 4
p: 0x7fff65c27810
*p: 5
p: 0x7fff65c27814
*p: 6
p: 0x7fff65c27818
*p: 7
p: 0x7fff65c2781c
*p: 8
p: 0x7fff65c27820
*p: 9
p: 0x7fff65c27824
*p: 10
```

### Structs / stacks
```C
struct stack {
  int elements[3];
  int top; // first free elements
};

void stack_init(struct stack *s) {
  s->top = 0;
}

int stack_push(struct stack *s, int x) {
  if (s->top == 3) {
    return 1;
  }
  s->elements[s->top] = x;
  s->top = s->top + 1;
  return 0;
}
```

We can update a stack by simply referring to its pointer $\texttt{\&s}$:
```C
int main(void) {
  struct stack s;
  stack_init(&s);
  assert(stack_push(&s, 100) == 0);
  assert(stack_push(&s, 200) == 0);
  assert(stack_push(&s, 300) == 0);
}
```

Others:
*Dereferencing*
# Exercises

## GDB
https://sourceware.org/gdb/onlinedocs/refcard.pdf
https://www.geeksforgeeks.org/gdb-step-by-step-introduction/