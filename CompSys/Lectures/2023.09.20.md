# Reading notes
[JG] 12-13

**Summary of 12**:
- The *memory* and *object* models have several layers of abstraction: physical memory, virtual memory, storage instances, object representation, and binary representation.
- Each object can be seen as an array of $\texttt{unsigned char}$
- $\texttt{union}$s serve to overlay different object types over the same object representation.
- Memory can be aligned differently according to the need for a specific data type. In particular, not all arrays of $\texttt{unsigned char}$ can be used to represent any object
 ## Unions
A *union* is a user-defined data type that allows you to store different types of data in the same memory location.

*Unions* are similar to *structs*. *Unions*, however,  don't collect objects of different type into one bigger object, but rather overlay an object with a different type interpretation, which allows *unions* to allocate memory that can be shared by all of their members. Unlike structs, where each member has its own distinct memory location, unions share a single memory space among their members.

## Memory and state
The value of all objects constitutes the state of the *abstract state machine*.

Câ€™s memory model provides a unique location for almost all objects through the & operator, and that location can be accessed and modified from different parts of the program through *pointers*.

Doing so makes the determination of the *abstract state* of an execution much more
difficult, if not impossible in many cases
```C
double blub(double const* a, double* b);

int main(void) {
	double c = 35;
	double d = 3.5;
	printf("blub is %g\n", blub(&c, &d));
	printf("after blub the sum is %g\n", c + d);
}
```

Here, we (as well as the compiler) only see a declaration of function $\texttt{blub}$, with no definition. So we cannot conclude much about what that function does to the objects its arguments point to.
# Lecture notes
## Memory allocation
### Arrays
An *array* is a multidimensional sequence of objects of the same type and size.

We will mostly cover:
- *Regular arrays*: all rows of a multi-dimensional array have the same size.
- *Homogeneous arrays*: all elements have the same type.

We can declare an $n\times m$ array as:
```C
double A[n][m];
```
and index it with for example:
```C
A[1][2]
```

But there are many *problems* with built-in arrays:
- They decay to pointers in many situations.
- They cannot be passed to a function without losing their size.
- They cannot be returned from a function at all.
- They are not values!

In C, arrays have a *pointer* its first element. Retrieving its length is not as straightforward as in higher level languages.

#### Dynamic arrays
C doesn't have useful *dynamic arrays*, but does have useful support for *dynamic memory allocation*.

Use $\texttt{malloc()}$ or $\texttt{calloc()}$ to obtain a block of memory with room for enough bytes to fit the array we need.

We can view these functions as *allocating* an "array of bytes", which we can then interpret as arrays of some other type. *Allocating* memory means you claim it, no one else can use it.

$\texttt{calloc()}$ initialises the block of bytes to zero. $\texttt{malloc()}$ doesn't initialise the blocks to zero and usually runs faster. 

An $\texttt{x}$-element array needs $\texttt{x*sizeof(t)}$ bytes, where $\texttt{t}$ is the element type.

*Always free any allocated memory*, using the $\texttt{free(ptr)}$ command. This is used to free allocated blocks (not elements).

#### One dimensional array
![[Pasted image 20230920104411.png]]

#### Multi-dimensional array
Machines provide a *one-dimensional memory space*.

When we want multi-dimensional arrays we need to specify a *mapping* between our desired multi-dimensional space and the machine's single-dimensional space

*Index functions* map a $d$-dimensional index to a single-dimensional index.

$$
I: \mathbb{N}^d \rightarrow \mathbb{N}
$$
Index functions are not necessarily literal C functions, but a conceptual description of how the array is laid out in memory.
##### Row-major order and column-major order
![[Pasted image 20230920104746.png]]

**Row-major indexing**
$$
(i, j) \mapsto i \times m+j
$$
**Column-major indexing**
$$
(i, j) \mapsto j \times n+i
$$
Intuition:
- Row-major indexing first skips $i$ rows each comprising $m$ elements, then jumps $j$ elements into the row we reach.
- This is why $n$ (the number of rows) is not used for row-major indexing.

Column-major has same intuition, but we skip size- $n$ columns instead.

*Stepping* is going "across" in a matrix  
*Jumping* is going "down" in a matrix

**Index functions in C**
```C
int idx2_rowmajor(int n, int m, int i, int j) {
	return i * m + j;
}
int idx2_colmajor(int n, int m, int i, int j) {
	return j * n + i;
}
```

**Index functions that handle out of bounds index**
```C
int idx2_rowmajor(int n, int m, int i, int j) {
	assert(i >= 0 && i < n);
	assert(j >= 0 && j < m);
	return i * m + j;
}
```

##### Higher dimensions
For a $d$-dimensional row-major array of shape $n_0 \times \cdots \times n_{d-1}$, the index function where $p$ is a $d$-dimensional index point is
$$
p \mapsto \sum_{0 \leq i<d} p_i \times \prod_{i<j<d} n_j
$$
where $p_i$ gets the $i$ th coordinate of $p$, and the product of an empty series is 1.

**Intuition**: $p_i$ tells us how many "*sub-arrays*" of size $n_{i+1} \ldots \times \ldots n_{d-1}$ we need to skip.


###### Example: four dimensional indexing
Suppose we have a row-major array of shape
$$
n_0 \times n_1 \times n_2 \times n_3
$$
and we wish to compute the flat index of element position
$$
\left(p_0, p_1, p_2, p_3\right)
$$
We then have to sum these terms where the strides $s_i$ depend on the array size:
$$
\begin{aligned}
& p_0 \times n_1 \times n_2 \times n_3 \\
+ & p_1 \times n_2 \times n_3 \\
+ & p_2 \times n_3 \\
+ & p_3 \times 1
\end{aligned}
$$
The stride $s_i$ is the product $\prod_{i<j<4} n_j$ of the array size after dropping the first $i+1$ dimensions.

##### Slicing
Since we represent arrays as the address of their first element, we must manually pass along the size when we call a function with an array.
```C
double sumvec(int n, const double *vector) {
	double sum = 0;
	for (int i = 0; i < n; i++) {
		sum += vector[i];
	}
	return sum;
}
```

When using row-major order, the elements of each row are adjacent in memory.

This allows us to perform efficient slicing, by taking the address of the first element in a row.

```C
void sumrows(int n, int m, const double *matrix, double *vector) {
	for (int i = 0; i < n; i++) {
		vector[i] = sumvec(m, &matrix[i*m]);
	}
}
```


# Exercises
$\texttt{structs}$ let us make our own data types (instead of $\texttt{int}$ or $\texttt{char}$). 