# Lecture notes

## Caching recap
### Direct mapping
- Each memory address maps to one cache block.
- Least significant bits of the address gives us the tag in the cache.
![[Pasted image 20230927101735.png]]

### Block sizes
- We always store more than a single byte in a block
- Usually 4 32 KiBs
- Note the differences between *byte addresses* and *block addresses*
![[Pasted image 20230927101912.png]]

### Fully associative mapping

Any block can be stored anywhere in cache. Now there's no clever indexing or tagging.

Not efficient, nobody does this.

### Set-associative mapping
Combination of direct and fully associative.

![[Pasted image 20230927102436.png]]

## Operating systems
![[Pasted image 20230927103144.png]]

OS is middleware between applications and hardware.

It provides standardised interfaces to resources.

Handles access control.

### Unix lifetime
![[Pasted image 20230927103420.png]]
### More than one process
So far we've made strictly *sequential* code, that does one thing after another. Computers run many processes at once to manage different devices and services.

**Program**: is a file containing code. Stateless and *dead*
**Process**: is a running *instance* of a program. The same program can be running in multiple instances. Stateful and *alive*.

Operating systems manage *processes*.
- Switching between *concurrent processes*
- Handling process termination
- Starting new processes

### The kernel
When we say *operating system* in this course we mean the *kernel*, and not the shell, GUI, C library, bundled applications etc.

**Kernel**: Code *always* stored in memory that services requests from the hardware and manage processes. *It is not a process*.

The kernel uses the same CPU, memory as ordinary code. The kernel maintains order of the memory and CPU.

Process code runs on the CPU in *unprivileged state*. When an *interrupt* happens, the CPU switches to *privileged state* and jumps to kernel code.


### Virtualising the CPU

**Context switching**:
- Pausing a process, saving its entire *state*, then resuming some other process based on its saved state (registers, contents of memory)

Doing *context switching* often and rapidly creates the illusion of simultaneous execution.

### System calls
Whenever we want to do IO we have to perform a *system call*.

**System call**: A request by a process that the kernel carries out some operations on its behalf.

**Remember**: *everything is a file*.
- IO is really just file manipulation
- Many OS calls are really just shortcuts to reading or writing to certain files
#### System call in RISC-V
The $\texttt{ecall}$ (*environment call*) instructions transfers control to the kernel.

https://github.com/TheThirdOne/rars/wiki/Environment-Calls


### Processes
```bash
pstree
```
```bash
htop
```
```bash
pkill -f [process_name]
```
