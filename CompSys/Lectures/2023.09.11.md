# Reading notes
[COD] 2.8-2.9 (p. 140)
[JG] 5-7 (p. 48)


## Procedures
*Procedures* are a way to implement *abstraction* in software. 

In the execution of a *procedure*, the program must follow these six 
steps:
1. Put *parameters* in a place where the procedure can access them.
2. *Transfer control* to the procedure.
3. Acquire the *storage resources* needed for the procedure.
4. *Perform* the desired task.
5. Put the result value in a place where the calling program can access it.
6. *Return control* to the point of origin, since a procedure can be called from 
several points in a program.

Conventionally, these 32 registers are allocated for calling procedures in **RISC-V**:
- $\texttt{x10-x17}$ (parameter registers)
- $\texttt{x1}$ (for returning to the point of origin)

**RISC-V** includes an instruction just for procedures: the *jump-and-link* ($\texttt{jal}$) instruction. It branches to an address and saves the address of the following instruction to the destination register, usually $\texttt{x1}$, which is called the *return address* or $\texttt{ra}$.

```
jal x1, ProcedureAddress
```


## ASCII
https://asciitable.com
*ASCII* stands for *American Standard Code for Information Interchange* and is the standard for representing 8-bit bytes as characters.
![[Pasted image 20230910215043.png]]

## C
![[Pasted image 20230911123614.png]]
Types with a grey background don't allow for arithmetic.

Before arithmetic, narrow integer types are promoted to $\texttt{signed int}$

![[Pasted image 20230911123804.png]]




# Lecture notes
## Functions and Text

### Jump and link
Our *assembler* is a simple linear order of instructions

*Jump-and-Link* jumps to an address and stores the call site address in the "*link
register*" $\texttt{x} _i$.

*Jump-and-Link-Register* takes address from register value.
- used to *return* from procedure

These instructions jump to a procedure and return to the same original order in the program.

### Stack

A *stack* is a region of memory where a *stack pointer* points to the top element
![[Pasted image 20230911132853.png]]
There is *nothing special* about a stack, it's just a region in memory.

Stacks in **RISC-V** grow from high to low.

#### Pushing and popping
We can either *push* or *pop* from our stack.

*Pushing* puts a value on-top of the stack, *popping* removes a value from the top.

### The call stack

When we say *stack* we usually refer to the *call stack*

**The idea of a call stack:**
- When we call a function, we push enough information to the stack to allow the called function to resume us when we are done.

- When we return from a function, we pop information from the stack to resume execution of the caller.

- Call stack is essentially a queue of functions waiting to resume execution.

### Calling conventions

- *Caller*  is the procedure making the procedure call (jumping from).
- *Callee*  is the procedure being called (jumping to).

#### Registers

**Registers that the caller uses**:
- $\texttt{a0-a7}$ for arguments
- $\texttt{ra}$ for *return address*
- $\texttt{a0}$ for the *return value*
- $\texttt{t0-t6}$ for *save registers*
![[Pasted image 20230911134916.png]]

### Examining representation of data
```C
void show_bytes(unsigned char* start, size_t len) {
	size_t i;
	for (i = 0; i < len; i++) {
		printf("%p\t0x%.2x\n", start+i, start[i]);
	}
	printf("\n");
}
```

Casting a pointer to an $\texttt{unsigned char*}$ allows us to treat it as a *byte array*

#### Hello world example
![[Pasted image 20230911142427.png]]
**Print sensibly!**

### Character sets
*Text* is an abstraction.

$\texttt{printf()}$ is determining how to represent *bytes* as letters (065 = A).
![[2023.09.11#Reading notes#ASCII]]

#### Turning numbers into text
```C
int x = 1234;
printf("x: %d\n", x);
```
![[Pasted image 20230911143020.png]]
![[Pasted image 20230911143106.png]]


Every string in C ends with $\textbackslash\texttt{0}$  

If a function takes a string as an argument it automatically sets $\textbackslash\texttt{0}$ at the end, otherwise we must put it there manually


### IO
All files are just *byte sequences*

A text file is a file that is understandable when the bytes are interpreted as characters (e.g. in ASCII).

**Takeaways:**
- Use $\texttt{printf()}$ for *text output*.
- Use $\texttt{scanf()}$ for *text input*.
- Use $\texttt{fwrite()}$ to *write raw data*.
- Use $\texttt{fread()}$ to *read raw data*.
- Raw data files are more compact and faster to read/write.