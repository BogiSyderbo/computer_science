# 2.26 exercises
[COD] p. 178 (249)
## 2.1
For the following C statement, write the corresponding RISC-V  assembly code. 

Assume that the C variables f, g, and h, have already been placed in registers x5, x6, and x7 respectively. Use a minimal number of RISC-V assembly instructions.

```C
f = g + (h - 5);
```

```RISC-V
addi x7 x7 -5      // h = h - 5
add x5 x6 x7       // f = g + h
```

## 2.2
Write a single C statement that corresponds to the two RISC-V assembly instructions below

```RISC-V
add f, g, h
add f, i, f
```

```C
f = i + (g + h)
```

## 2.3
For the following C statement, write the corresponding RISC-V assembly code. Assume that variables f, g, h, i, and j are assigned to registers x5, x6, x7, and x29, respectively.

Assume that the base address of the arrays A and B are in registers x10 and x11, respectively.

```C
B[8] = A[i-j]
```

This solution assumes that the arrays are byte arrays.
```RISC-V
sub  x7, x7, x29   # i = i - j
add  x7, x7, x10   # i = i + A (adding the offset)
lb   x7, 0(x7)     # i = Mem[i] (load the byte at A[i - j] into i)
sb   x7, 8(x11)    # Mem[B+8] = i
```

## 2.4
For the RISC-V assembly instructions below, what is the corresponding C statement? Assume that the variables f, g, h, i, and j are assigned  to registers x5, x6, x7, x28, and x29, respectively. Assume that the base address of the arrays A and B are in registers x10 and x11, respectively.

```RISC-V
slli x30, x5, 3     // x30 = f*8
add x30, x10, x30   // x30 = &A[f]
slli x31, x6, 3     // x31 = g*8
add x31, x11, x31   // x31 = &B[g]
lw x5, 0(x30)       // f = A[f]

addi x12, x30, 8    // x12 = &A[f + 1]
lw x30, 0(x12)      // x30 = &A[f + 1]
add x30, x30, x5    // x30 = A[f] + &A[f + 1]
lw x30, 0(x31)      // B[g] = x30
 ```


```C
B[g] = A[f] + A[f + 1]
```

## 2.5
Show how the value $\texttt{0xabcdef12}$ would be arranged in memory of a little-endian and a big-endian machine. Assume the data are stored starting at address 0 and that the word size is 4 bytes.
![[2023.09.06#Byte ordering]]

**Big endian**:
Address   Byte
0           ab
1           cd
2           ef
3           12

**Little endian**:
Address   Byte
0           12
1           ef
2           cd
3           ab

## 2.24
```RISC-V
LOOP:
	beq x6, x0, DONE
    addi x6, x6, -1
    addi x5, x5, 2
    jal x0, LOOP
DONE:
```
### 1
Assume that the register $\texttt{x6}$ is initialized to the value 10. What 
is the final value in register $\texttt{x5}$ assuming the $\texttt{x5}$ is initially zero?

It will be 20, since 2 is added to $\texttt{x5}$ for every iteration of the loop while $\texttt{x6}$ is decremented by 1. The loop terminates after 10 iterations since $\texttt{x6}$ will equal  zero.

### 2
For the loop above, write the equivalent C code. Assume that the registers $\texttt{x5}$ and $\texttt{x6}$ are integers $\texttt{acc}$ and $\texttt{i}$, respectively.

```C
while (i != 0) {
	i--;
	acc += 2;
}
```

### 3
For the loop written in RISC-V assembly above, assume that the register $\texttt{x6}$ is initialized to the value N. How many RISC-V instructions are executed?

$n$ executions for all except $\texttt{beq}$, which is executed $n+1$ times. This means that the total number of instructions is $n\cdot 4 + 1$.

### 4
For the loop written in RISC-V assembly above, replace the instruction $\texttt{beq x6, x0, DONE}$ with the instruction $\texttt{blt x6, x0, DONE}$ 
and write the equivalent C code.

```RISC-V
LOOP:
	blt x6, x0, DONE
    addi x6, x6, -1
    addi x5, x5, 2
    jal x0, LOOP
DONE:
```

```C
while (i >= 0) {
	i--;
	acc += 2;
}
```

## 2.25
Translate the following C code to RISC-V assembly code. Use 
a minimum number of instructions. Assume that the values of a, b, i, and j are in registers x5, x6, x7, and x29, respectively. Also, assume that register x10 holds the base address of the array D.

```C
for(i=0; i<a; i++)
	for(j=0; j<b; j++)
	    D[4*j] = i + j;
```

```RISC-V
L0:  
		beq x7, x5, DONE0           // i < a
        addi x29, x0, 0             // j = 0
L1: 
		beq x29, x6, DONE1          // j < b
        slli x30, x29, 2            // x30 = j*4
        slli x30, x30, 2            // x30 *= 4
        add x30, x10, x30           // x30 += x10 (adding the base)
        add x31, x7, x29,           // x31 = i + j
        sw x31 0(x30)               // D[4*j] = i + j
        addi x29, x29, 1            // j++
        jal x0, L1                  // jump to L1
DONE1:
        addi x7, x7, 1              // i++
        jal x0, L0                  // jump to L0
DONE0:
```